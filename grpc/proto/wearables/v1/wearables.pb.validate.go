// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: proto/wearables/v1/wearables.proto

package wearables

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on WearableStats with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *WearableStats) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WearableStats with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in WearableStatsMultiError, or
// nil if none found.
func (m *WearableStats) ValidateAll() error {
	return m.validate(true)
}

func (m *WearableStats) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Creativity

	// no validation rules for Charisma

	// no validation rules for Resolve

	// no validation rules for Fitness

	// no validation rules for Intellect

	if len(errors) > 0 {
		return WearableStatsMultiError(errors)
	}

	return nil
}

// WearableStatsMultiError is an error wrapping multiple validation errors
// returned by WearableStats.ValidateAll() if the designated constraints
// aren't met.
type WearableStatsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WearableStatsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WearableStatsMultiError) AllErrors() []error { return m }

// WearableStatsValidationError is the validation error returned by
// WearableStats.Validate if the designated constraints aren't met.
type WearableStatsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WearableStatsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WearableStatsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WearableStatsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WearableStatsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WearableStatsValidationError) ErrorName() string { return "WearableStatsValidationError" }

// Error satisfies the builtin error interface
func (e WearableStatsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWearableStats.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WearableStatsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WearableStatsValidationError{}

// Validate checks the field values on Wearables with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Wearables) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Wearables with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in WearablesMultiError, or nil
// if none found.
func (m *Wearables) ValidateAll() error {
	return m.validate(true)
}

func (m *Wearables) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for WearableId

	// no validation rules for Type

	// no validation rules for Name

	// no validation rules for Gender

	// no validation rules for Rarity

	// no validation rules for Changeable

	// no validation rules for IsOrigin

	// no validation rules for IsRequired

	// no validation rules for Image

	if all {
		switch v := interface{}(m.GetStats()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WearablesValidationError{
					field:  "Stats",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WearablesValidationError{
					field:  "Stats",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStats()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WearablesValidationError{
				field:  "Stats",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for OnChainId

	if len(errors) > 0 {
		return WearablesMultiError(errors)
	}

	return nil
}

// WearablesMultiError is an error wrapping multiple validation errors returned
// by Wearables.ValidateAll() if the designated constraints aren't met.
type WearablesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WearablesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WearablesMultiError) AllErrors() []error { return m }

// WearablesValidationError is the validation error returned by
// Wearables.Validate if the designated constraints aren't met.
type WearablesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WearablesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WearablesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WearablesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WearablesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WearablesValidationError) ErrorName() string { return "WearablesValidationError" }

// Error satisfies the builtin error interface
func (e WearablesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWearables.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WearablesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WearablesValidationError{}

// Validate checks the field values on WearableOnchainData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WearableOnchainData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WearableOnchainData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WearableOnchainDataMultiError, or nil if none found.
func (m *WearableOnchainData) ValidateAll() error {
	return m.validate(true)
}

func (m *WearableOnchainData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for MaxSupply

	// no validation rules for CurrentSupply

	// no validation rules for Type

	// no validation rules for Rarity

	// no validation rules for CreatedAtTimestamp

	// no validation rules for UpdatedAtTimestamp

	// no validation rules for CreatedAtBlock

	// no validation rules for UpdatedAtBlock

	if len(errors) > 0 {
		return WearableOnchainDataMultiError(errors)
	}

	return nil
}

// WearableOnchainDataMultiError is an error wrapping multiple validation
// errors returned by WearableOnchainData.ValidateAll() if the designated
// constraints aren't met.
type WearableOnchainDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WearableOnchainDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WearableOnchainDataMultiError) AllErrors() []error { return m }

// WearableOnchainDataValidationError is the validation error returned by
// WearableOnchainData.Validate if the designated constraints aren't met.
type WearableOnchainDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WearableOnchainDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WearableOnchainDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WearableOnchainDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WearableOnchainDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WearableOnchainDataValidationError) ErrorName() string {
	return "WearableOnchainDataValidationError"
}

// Error satisfies the builtin error interface
func (e WearableOnchainDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWearableOnchainData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WearableOnchainDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WearableOnchainDataValidationError{}

// Validate checks the field values on WearableActivity with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *WearableActivity) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WearableActivity with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WearableActivityMultiError, or nil if none found.
func (m *WearableActivity) ValidateAll() error {
	return m.validate(true)
}

func (m *WearableActivity) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for OnChainData

	// no validation rules for ActivityType

	// no validation rules for TimeStamp

	// no validation rules for BlockNumber

	// no validation rules for Txhash

	// no validation rules for Amount

	// no validation rules for Price

	// no validation rules for From

	// no validation rules for To

	if len(errors) > 0 {
		return WearableActivityMultiError(errors)
	}

	return nil
}

// WearableActivityMultiError is an error wrapping multiple validation errors
// returned by WearableActivity.ValidateAll() if the designated constraints
// aren't met.
type WearableActivityMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WearableActivityMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WearableActivityMultiError) AllErrors() []error { return m }

// WearableActivityValidationError is the validation error returned by
// WearableActivity.Validate if the designated constraints aren't met.
type WearableActivityValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WearableActivityValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WearableActivityValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WearableActivityValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WearableActivityValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WearableActivityValidationError) ErrorName() string { return "WearableActivityValidationError" }

// Error satisfies the builtin error interface
func (e WearableActivityValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWearableActivity.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WearableActivityValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WearableActivityValidationError{}

// Validate checks the field values on WearableListingOrOffer with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WearableListingOrOffer) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WearableListingOrOffer with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WearableListingOrOfferMultiError, or nil if none found.
func (m *WearableListingOrOffer) ValidateAll() error {
	return m.validate(true)
}

func (m *WearableListingOrOffer) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for OnChainId

	// no validation rules for FromAccount

	// no validation rules for Price

	// no validation rules for Amount

	// no validation rules for TimeStamp

	// no validation rules for BlockNumber

	// no validation rules for Txhash

	if len(errors) > 0 {
		return WearableListingOrOfferMultiError(errors)
	}

	return nil
}

// WearableListingOrOfferMultiError is an error wrapping multiple validation
// errors returned by WearableListingOrOffer.ValidateAll() if the designated
// constraints aren't met.
type WearableListingOrOfferMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WearableListingOrOfferMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WearableListingOrOfferMultiError) AllErrors() []error { return m }

// WearableListingOrOfferValidationError is the validation error returned by
// WearableListingOrOffer.Validate if the designated constraints aren't met.
type WearableListingOrOfferValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WearableListingOrOfferValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WearableListingOrOfferValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WearableListingOrOfferValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WearableListingOrOfferValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WearableListingOrOfferValidationError) ErrorName() string {
	return "WearableListingOrOfferValidationError"
}

// Error satisfies the builtin error interface
func (e WearableListingOrOfferValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWearableListingOrOffer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WearableListingOrOfferValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WearableListingOrOfferValidationError{}

// Validate checks the field values on WearablesInformation with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WearablesInformation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WearablesInformation with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WearablesInformationMultiError, or nil if none found.
func (m *WearablesInformation) ValidateAll() error {
	return m.validate(true)
}

func (m *WearablesInformation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WearableId

	// no validation rules for Type

	// no validation rules for Name

	// no validation rules for Gender

	// no validation rules for Rarity

	// no validation rules for Changeable

	// no validation rules for IsOrigin

	// no validation rules for IsRequired

	// no validation rules for Images

	if all {
		switch v := interface{}(m.GetStats()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WearablesInformationValidationError{
					field:  "Stats",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WearablesInformationValidationError{
					field:  "Stats",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStats()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WearablesInformationValidationError{
				field:  "Stats",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MaxSupply

	// no validation rules for CurrentSupply

	// no validation rules for CreatedAtTimestamp

	// no validation rules for UpdatedAtTimestamp

	// no validation rules for CreatedAtBlock

	// no validation rules for UpdateAtBlock

	// no validation rules for OnChainId

	if len(errors) > 0 {
		return WearablesInformationMultiError(errors)
	}

	return nil
}

// WearablesInformationMultiError is an error wrapping multiple validation
// errors returned by WearablesInformation.ValidateAll() if the designated
// constraints aren't met.
type WearablesInformationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WearablesInformationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WearablesInformationMultiError) AllErrors() []error { return m }

// WearablesInformationValidationError is the validation error returned by
// WearablesInformation.Validate if the designated constraints aren't met.
type WearablesInformationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WearablesInformationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WearablesInformationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WearablesInformationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WearablesInformationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WearablesInformationValidationError) ErrorName() string {
	return "WearablesInformationValidationError"
}

// Error satisfies the builtin error interface
func (e WearablesInformationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWearablesInformation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WearablesInformationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WearablesInformationValidationError{}

// Validate checks the field values on GetWearablesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetWearablesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetWearablesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetWearablesRequestMultiError, or nil if none found.
func (m *GetWearablesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetWearablesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() == nil {
		err := GetWearablesRequestValidationError{
			field:  "Id",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetWearablesRequestValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetWearablesRequestValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetWearablesRequestValidationError{
				field:  "Id",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetWearablesRequestMultiError(errors)
	}

	return nil
}

// GetWearablesRequestMultiError is an error wrapping multiple validation
// errors returned by GetWearablesRequest.ValidateAll() if the designated
// constraints aren't met.
type GetWearablesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetWearablesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetWearablesRequestMultiError) AllErrors() []error { return m }

// GetWearablesRequestValidationError is the validation error returned by
// GetWearablesRequest.Validate if the designated constraints aren't met.
type GetWearablesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetWearablesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetWearablesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetWearablesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetWearablesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetWearablesRequestValidationError) ErrorName() string {
	return "GetWearablesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetWearablesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetWearablesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetWearablesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetWearablesRequestValidationError{}

// Validate checks the field values on GetWearablesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetWearablesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetWearablesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetWearablesResponseMultiError, or nil if none found.
func (m *GetWearablesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetWearablesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetWearables()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetWearablesResponseValidationError{
					field:  "Wearables",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetWearablesResponseValidationError{
					field:  "Wearables",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWearables()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetWearablesResponseValidationError{
				field:  "Wearables",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetWearablesResponseMultiError(errors)
	}

	return nil
}

// GetWearablesResponseMultiError is an error wrapping multiple validation
// errors returned by GetWearablesResponse.ValidateAll() if the designated
// constraints aren't met.
type GetWearablesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetWearablesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetWearablesResponseMultiError) AllErrors() []error { return m }

// GetWearablesResponseValidationError is the validation error returned by
// GetWearablesResponse.Validate if the designated constraints aren't met.
type GetWearablesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetWearablesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetWearablesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetWearablesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetWearablesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetWearablesResponseValidationError) ErrorName() string {
	return "GetWearablesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetWearablesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetWearablesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetWearablesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetWearablesResponseValidationError{}

// Validate checks the field values on GetListWearablesActivityRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetListWearablesActivityRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetListWearablesActivityRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetListWearablesActivityRequestMultiError, or nil if none found.
func (m *GetListWearablesActivityRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetListWearablesActivityRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetOffset() < 0 {
		err := GetListWearablesActivityRequestValidationError{
			field:  "Offset",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetLimit(); val < 0 || val > 50 {
		err := GetListWearablesActivityRequestValidationError{
			field:  "Limit",
			reason: "value must be inside range [0, 50]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetListWearablesActivityRequestMultiError(errors)
	}

	return nil
}

// GetListWearablesActivityRequestMultiError is an error wrapping multiple
// validation errors returned by GetListWearablesActivityRequest.ValidateAll()
// if the designated constraints aren't met.
type GetListWearablesActivityRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetListWearablesActivityRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetListWearablesActivityRequestMultiError) AllErrors() []error { return m }

// GetListWearablesActivityRequestValidationError is the validation error
// returned by GetListWearablesActivityRequest.Validate if the designated
// constraints aren't met.
type GetListWearablesActivityRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetListWearablesActivityRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetListWearablesActivityRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetListWearablesActivityRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetListWearablesActivityRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetListWearablesActivityRequestValidationError) ErrorName() string {
	return "GetListWearablesActivityRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetListWearablesActivityRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetListWearablesActivityRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetListWearablesActivityRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetListWearablesActivityRequestValidationError{}

// Validate checks the field values on GetListWearablesActivityResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GetListWearablesActivityResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetListWearablesActivityResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetListWearablesActivityResponseMultiError, or nil if none found.
func (m *GetListWearablesActivityResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetListWearablesActivityResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetWearableActivity() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetListWearablesActivityResponseValidationError{
						field:  fmt.Sprintf("WearableActivity[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetListWearablesActivityResponseValidationError{
						field:  fmt.Sprintf("WearableActivity[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetListWearablesActivityResponseValidationError{
					field:  fmt.Sprintf("WearableActivity[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Count

	if len(errors) > 0 {
		return GetListWearablesActivityResponseMultiError(errors)
	}

	return nil
}

// GetListWearablesActivityResponseMultiError is an error wrapping multiple
// validation errors returned by
// GetListWearablesActivityResponse.ValidateAll() if the designated
// constraints aren't met.
type GetListWearablesActivityResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetListWearablesActivityResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetListWearablesActivityResponseMultiError) AllErrors() []error { return m }

// GetListWearablesActivityResponseValidationError is the validation error
// returned by GetListWearablesActivityResponse.Validate if the designated
// constraints aren't met.
type GetListWearablesActivityResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetListWearablesActivityResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetListWearablesActivityResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetListWearablesActivityResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetListWearablesActivityResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetListWearablesActivityResponseValidationError) ErrorName() string {
	return "GetListWearablesActivityResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetListWearablesActivityResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetListWearablesActivityResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetListWearablesActivityResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetListWearablesActivityResponseValidationError{}

// Validate checks the field values on GetWearablesListingRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetWearablesListingRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetWearablesListingRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetWearablesListingRequestMultiError, or nil if none found.
func (m *GetWearablesListingRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetWearablesListingRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() == nil {
		err := GetWearablesListingRequestValidationError{
			field:  "Id",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetWearablesListingRequestValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetWearablesListingRequestValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetWearablesListingRequestValidationError{
				field:  "Id",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetWearablesListingRequestMultiError(errors)
	}

	return nil
}

// GetWearablesListingRequestMultiError is an error wrapping multiple
// validation errors returned by GetWearablesListingRequest.ValidateAll() if
// the designated constraints aren't met.
type GetWearablesListingRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetWearablesListingRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetWearablesListingRequestMultiError) AllErrors() []error { return m }

// GetWearablesListingRequestValidationError is the validation error returned
// by GetWearablesListingRequest.Validate if the designated constraints aren't met.
type GetWearablesListingRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetWearablesListingRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetWearablesListingRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetWearablesListingRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetWearablesListingRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetWearablesListingRequestValidationError) ErrorName() string {
	return "GetWearablesListingRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetWearablesListingRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetWearablesListingRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetWearablesListingRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetWearablesListingRequestValidationError{}

// Validate checks the field values on GetWearablesListingResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetWearablesListingResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetWearablesListingResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetWearablesListingResponseMultiError, or nil if none found.
func (m *GetWearablesListingResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetWearablesListingResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetWearableListing()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetWearablesListingResponseValidationError{
					field:  "WearableListing",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetWearablesListingResponseValidationError{
					field:  "WearableListing",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWearableListing()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetWearablesListingResponseValidationError{
				field:  "WearableListing",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetWearablesListingResponseMultiError(errors)
	}

	return nil
}

// GetWearablesListingResponseMultiError is an error wrapping multiple
// validation errors returned by GetWearablesListingResponse.ValidateAll() if
// the designated constraints aren't met.
type GetWearablesListingResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetWearablesListingResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetWearablesListingResponseMultiError) AllErrors() []error { return m }

// GetWearablesListingResponseValidationError is the validation error returned
// by GetWearablesListingResponse.Validate if the designated constraints
// aren't met.
type GetWearablesListingResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetWearablesListingResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetWearablesListingResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetWearablesListingResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetWearablesListingResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetWearablesListingResponseValidationError) ErrorName() string {
	return "GetWearablesListingResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetWearablesListingResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetWearablesListingResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetWearablesListingResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetWearablesListingResponseValidationError{}

// Validate checks the field values on GetWearablesOfferRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetWearablesOfferRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetWearablesOfferRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetWearablesOfferRequestMultiError, or nil if none found.
func (m *GetWearablesOfferRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetWearablesOfferRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() == nil {
		err := GetWearablesOfferRequestValidationError{
			field:  "Id",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetWearablesOfferRequestValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetWearablesOfferRequestValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetWearablesOfferRequestValidationError{
				field:  "Id",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetWearablesOfferRequestMultiError(errors)
	}

	return nil
}

// GetWearablesOfferRequestMultiError is an error wrapping multiple validation
// errors returned by GetWearablesOfferRequest.ValidateAll() if the designated
// constraints aren't met.
type GetWearablesOfferRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetWearablesOfferRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetWearablesOfferRequestMultiError) AllErrors() []error { return m }

// GetWearablesOfferRequestValidationError is the validation error returned by
// GetWearablesOfferRequest.Validate if the designated constraints aren't met.
type GetWearablesOfferRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetWearablesOfferRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetWearablesOfferRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetWearablesOfferRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetWearablesOfferRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetWearablesOfferRequestValidationError) ErrorName() string {
	return "GetWearablesOfferRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetWearablesOfferRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetWearablesOfferRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetWearablesOfferRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetWearablesOfferRequestValidationError{}

// Validate checks the field values on GetWearablesOfferResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetWearablesOfferResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetWearablesOfferResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetWearablesOfferResponseMultiError, or nil if none found.
func (m *GetWearablesOfferResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetWearablesOfferResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetWearableOffer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetWearablesOfferResponseValidationError{
					field:  "WearableOffer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetWearablesOfferResponseValidationError{
					field:  "WearableOffer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWearableOffer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetWearablesOfferResponseValidationError{
				field:  "WearableOffer",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetWearablesOfferResponseMultiError(errors)
	}

	return nil
}

// GetWearablesOfferResponseMultiError is an error wrapping multiple validation
// errors returned by GetWearablesOfferResponse.ValidateAll() if the
// designated constraints aren't met.
type GetWearablesOfferResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetWearablesOfferResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetWearablesOfferResponseMultiError) AllErrors() []error { return m }

// GetWearablesOfferResponseValidationError is the validation error returned by
// GetWearablesOfferResponse.Validate if the designated constraints aren't met.
type GetWearablesOfferResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetWearablesOfferResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetWearablesOfferResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetWearablesOfferResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetWearablesOfferResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetWearablesOfferResponseValidationError) ErrorName() string {
	return "GetWearablesOfferResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetWearablesOfferResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetWearablesOfferResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetWearablesOfferResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetWearablesOfferResponseValidationError{}

// Validate checks the field values on GetListWearablesListingRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetListWearablesListingRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetListWearablesListingRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetListWearablesListingRequestMultiError, or nil if none found.
func (m *GetListWearablesListingRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetListWearablesListingRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetOffset() < 0 {
		err := GetListWearablesListingRequestValidationError{
			field:  "Offset",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetLimit(); val < 0 || val > 50 {
		err := GetListWearablesListingRequestValidationError{
			field:  "Limit",
			reason: "value must be inside range [0, 50]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetListWearablesListingRequestMultiError(errors)
	}

	return nil
}

// GetListWearablesListingRequestMultiError is an error wrapping multiple
// validation errors returned by GetListWearablesListingRequest.ValidateAll()
// if the designated constraints aren't met.
type GetListWearablesListingRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetListWearablesListingRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetListWearablesListingRequestMultiError) AllErrors() []error { return m }

// GetListWearablesListingRequestValidationError is the validation error
// returned by GetListWearablesListingRequest.Validate if the designated
// constraints aren't met.
type GetListWearablesListingRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetListWearablesListingRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetListWearablesListingRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetListWearablesListingRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetListWearablesListingRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetListWearablesListingRequestValidationError) ErrorName() string {
	return "GetListWearablesListingRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetListWearablesListingRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetListWearablesListingRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetListWearablesListingRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetListWearablesListingRequestValidationError{}

// Validate checks the field values on GetListWearablesListingResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetListWearablesListingResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetListWearablesListingResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetListWearablesListingResponseMultiError, or nil if none found.
func (m *GetListWearablesListingResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetListWearablesListingResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetWearablesListing() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetListWearablesListingResponseValidationError{
						field:  fmt.Sprintf("WearablesListing[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetListWearablesListingResponseValidationError{
						field:  fmt.Sprintf("WearablesListing[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetListWearablesListingResponseValidationError{
					field:  fmt.Sprintf("WearablesListing[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Count

	if len(errors) > 0 {
		return GetListWearablesListingResponseMultiError(errors)
	}

	return nil
}

// GetListWearablesListingResponseMultiError is an error wrapping multiple
// validation errors returned by GetListWearablesListingResponse.ValidateAll()
// if the designated constraints aren't met.
type GetListWearablesListingResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetListWearablesListingResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetListWearablesListingResponseMultiError) AllErrors() []error { return m }

// GetListWearablesListingResponseValidationError is the validation error
// returned by GetListWearablesListingResponse.Validate if the designated
// constraints aren't met.
type GetListWearablesListingResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetListWearablesListingResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetListWearablesListingResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetListWearablesListingResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetListWearablesListingResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetListWearablesListingResponseValidationError) ErrorName() string {
	return "GetListWearablesListingResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetListWearablesListingResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetListWearablesListingResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetListWearablesListingResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetListWearablesListingResponseValidationError{}

// Validate checks the field values on GetListWearablesOfferRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetListWearablesOfferRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetListWearablesOfferRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetListWearablesOfferRequestMultiError, or nil if none found.
func (m *GetListWearablesOfferRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetListWearablesOfferRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetOffset() < 0 {
		err := GetListWearablesOfferRequestValidationError{
			field:  "Offset",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetLimit(); val < 0 || val > 50 {
		err := GetListWearablesOfferRequestValidationError{
			field:  "Limit",
			reason: "value must be inside range [0, 50]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetListWearablesOfferRequestMultiError(errors)
	}

	return nil
}

// GetListWearablesOfferRequestMultiError is an error wrapping multiple
// validation errors returned by GetListWearablesOfferRequest.ValidateAll() if
// the designated constraints aren't met.
type GetListWearablesOfferRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetListWearablesOfferRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetListWearablesOfferRequestMultiError) AllErrors() []error { return m }

// GetListWearablesOfferRequestValidationError is the validation error returned
// by GetListWearablesOfferRequest.Validate if the designated constraints
// aren't met.
type GetListWearablesOfferRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetListWearablesOfferRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetListWearablesOfferRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetListWearablesOfferRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetListWearablesOfferRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetListWearablesOfferRequestValidationError) ErrorName() string {
	return "GetListWearablesOfferRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetListWearablesOfferRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetListWearablesOfferRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetListWearablesOfferRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetListWearablesOfferRequestValidationError{}

// Validate checks the field values on GetListWearablesOfferResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetListWearablesOfferResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetListWearablesOfferResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetListWearablesOfferResponseMultiError, or nil if none found.
func (m *GetListWearablesOfferResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetListWearablesOfferResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetWearablesOffer() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetListWearablesOfferResponseValidationError{
						field:  fmt.Sprintf("WearablesOffer[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetListWearablesOfferResponseValidationError{
						field:  fmt.Sprintf("WearablesOffer[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetListWearablesOfferResponseValidationError{
					field:  fmt.Sprintf("WearablesOffer[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Count

	if len(errors) > 0 {
		return GetListWearablesOfferResponseMultiError(errors)
	}

	return nil
}

// GetListWearablesOfferResponseMultiError is an error wrapping multiple
// validation errors returned by GetListWearablesOfferResponse.ValidateAll()
// if the designated constraints aren't met.
type GetListWearablesOfferResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetListWearablesOfferResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetListWearablesOfferResponseMultiError) AllErrors() []error { return m }

// GetListWearablesOfferResponseValidationError is the validation error
// returned by GetListWearablesOfferResponse.Validate if the designated
// constraints aren't met.
type GetListWearablesOfferResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetListWearablesOfferResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetListWearablesOfferResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetListWearablesOfferResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetListWearablesOfferResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetListWearablesOfferResponseValidationError) ErrorName() string {
	return "GetListWearablesOfferResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetListWearablesOfferResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetListWearablesOfferResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetListWearablesOfferResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetListWearablesOfferResponseValidationError{}

// Validate checks the field values on GetListWearablesInformationRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GetListWearablesInformationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetListWearablesInformationRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GetListWearablesInformationRequestMultiError, or nil if none found.
func (m *GetListWearablesInformationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetListWearablesInformationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetOffset() < 0 {
		err := GetListWearablesInformationRequestValidationError{
			field:  "Offset",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetLimit(); val < 0 || val > 50 {
		err := GetListWearablesInformationRequestValidationError{
			field:  "Limit",
			reason: "value must be inside range [0, 50]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _GetListWearablesInformationRequest_Sort_InLookup[m.GetSort()]; !ok {
		err := GetListWearablesInformationRequestValidationError{
			field:  "Sort",
			reason: "value must be in list [ lowest_current_supply highest_current_supply lowest_max_supply highest_max_supply]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _GetListWearablesInformationRequest_Rarity_InLookup[m.GetRarity()]; !ok {
		err := GetListWearablesInformationRequestValidationError{
			field:  "Rarity",
			reason: "value must be in list [common uncommon rare epic legendary mythical]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetGender() {
		_, _ = idx, item

		if _, ok := _GetListWearablesInformationRequest_Gender_InLookup[item]; !ok {
			err := GetListWearablesInformationRequestValidationError{
				field:  fmt.Sprintf("Gender[%v]", idx),
				reason: "value must be in list [male female]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if _, ok := _GetListWearablesInformationRequest_Type_InLookup[m.GetType()]; !ok {
		err := GetListWearablesInformationRequestValidationError{
			field:  "Type",
			reason: "value must be in list [all hair skin face face_accessories top bottom shoes coat left_hand_equipment right_hand_equipment vehicles wing tail pet set]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetListWearablesInformationRequestMultiError(errors)
	}

	return nil
}

// GetListWearablesInformationRequestMultiError is an error wrapping multiple
// validation errors returned by
// GetListWearablesInformationRequest.ValidateAll() if the designated
// constraints aren't met.
type GetListWearablesInformationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetListWearablesInformationRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetListWearablesInformationRequestMultiError) AllErrors() []error { return m }

// GetListWearablesInformationRequestValidationError is the validation error
// returned by GetListWearablesInformationRequest.Validate if the designated
// constraints aren't met.
type GetListWearablesInformationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetListWearablesInformationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetListWearablesInformationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetListWearablesInformationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetListWearablesInformationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetListWearablesInformationRequestValidationError) ErrorName() string {
	return "GetListWearablesInformationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetListWearablesInformationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetListWearablesInformationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetListWearablesInformationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetListWearablesInformationRequestValidationError{}

var _GetListWearablesInformationRequest_Sort_InLookup = map[string]struct{}{
	"":                       {},
	"lowest_current_supply":  {},
	"highest_current_supply": {},
	"lowest_max_supply":      {},
	"highest_max_supply":     {},
}

var _GetListWearablesInformationRequest_Rarity_InLookup = map[string]struct{}{
	"common":    {},
	"uncommon":  {},
	"rare":      {},
	"epic":      {},
	"legendary": {},
	"mythical":  {},
}

var _GetListWearablesInformationRequest_Gender_InLookup = map[string]struct{}{
	"male":   {},
	"female": {},
}

var _GetListWearablesInformationRequest_Type_InLookup = map[string]struct{}{
	"all":                  {},
	"hair":                 {},
	"skin":                 {},
	"face":                 {},
	"face_accessories":     {},
	"top":                  {},
	"bottom":               {},
	"shoes":                {},
	"coat":                 {},
	"left_hand_equipment":  {},
	"right_hand_equipment": {},
	"vehicles":             {},
	"wing":                 {},
	"tail":                 {},
	"pet":                  {},
	"set":                  {},
}

// Validate checks the field values on GetWearablesInformationRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetWearablesInformationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetWearablesInformationRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetWearablesInformationRequestMultiError, or nil if none found.
func (m *GetWearablesInformationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetWearablesInformationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() == nil {
		err := GetWearablesInformationRequestValidationError{
			field:  "Id",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetWearablesInformationRequestValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetWearablesInformationRequestValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetWearablesInformationRequestValidationError{
				field:  "Id",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetWearablesInformationRequestMultiError(errors)
	}

	return nil
}

// GetWearablesInformationRequestMultiError is an error wrapping multiple
// validation errors returned by GetWearablesInformationRequest.ValidateAll()
// if the designated constraints aren't met.
type GetWearablesInformationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetWearablesInformationRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetWearablesInformationRequestMultiError) AllErrors() []error { return m }

// GetWearablesInformationRequestValidationError is the validation error
// returned by GetWearablesInformationRequest.Validate if the designated
// constraints aren't met.
type GetWearablesInformationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetWearablesInformationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetWearablesInformationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetWearablesInformationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetWearablesInformationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetWearablesInformationRequestValidationError) ErrorName() string {
	return "GetWearablesInformationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetWearablesInformationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetWearablesInformationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetWearablesInformationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetWearablesInformationRequestValidationError{}

// Validate checks the field values on GetWearablesInformationResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetWearablesInformationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetWearablesInformationResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetWearablesInformationResponseMultiError, or nil if none found.
func (m *GetWearablesInformationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetWearablesInformationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetWearableInformation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetWearablesInformationResponseValidationError{
					field:  "WearableInformation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetWearablesInformationResponseValidationError{
					field:  "WearableInformation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWearableInformation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetWearablesInformationResponseValidationError{
				field:  "WearableInformation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetWearablesInformationResponseMultiError(errors)
	}

	return nil
}

// GetWearablesInformationResponseMultiError is an error wrapping multiple
// validation errors returned by GetWearablesInformationResponse.ValidateAll()
// if the designated constraints aren't met.
type GetWearablesInformationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetWearablesInformationResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetWearablesInformationResponseMultiError) AllErrors() []error { return m }

// GetWearablesInformationResponseValidationError is the validation error
// returned by GetWearablesInformationResponse.Validate if the designated
// constraints aren't met.
type GetWearablesInformationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetWearablesInformationResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetWearablesInformationResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetWearablesInformationResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetWearablesInformationResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetWearablesInformationResponseValidationError) ErrorName() string {
	return "GetWearablesInformationResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetWearablesInformationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetWearablesInformationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetWearablesInformationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetWearablesInformationResponseValidationError{}

// Validate checks the field values on GetListWearablesInformationResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GetListWearablesInformationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetListWearablesInformationResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GetListWearablesInformationResponseMultiError, or nil if none found.
func (m *GetListWearablesInformationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetListWearablesInformationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetWearableInformation() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetListWearablesInformationResponseValidationError{
						field:  fmt.Sprintf("WearableInformation[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetListWearablesInformationResponseValidationError{
						field:  fmt.Sprintf("WearableInformation[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetListWearablesInformationResponseValidationError{
					field:  fmt.Sprintf("WearableInformation[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Count

	if len(errors) > 0 {
		return GetListWearablesInformationResponseMultiError(errors)
	}

	return nil
}

// GetListWearablesInformationResponseMultiError is an error wrapping multiple
// validation errors returned by
// GetListWearablesInformationResponse.ValidateAll() if the designated
// constraints aren't met.
type GetListWearablesInformationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetListWearablesInformationResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetListWearablesInformationResponseMultiError) AllErrors() []error { return m }

// GetListWearablesInformationResponseValidationError is the validation error
// returned by GetListWearablesInformationResponse.Validate if the designated
// constraints aren't met.
type GetListWearablesInformationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetListWearablesInformationResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetListWearablesInformationResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetListWearablesInformationResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetListWearablesInformationResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetListWearablesInformationResponseValidationError) ErrorName() string {
	return "GetListWearablesInformationResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetListWearablesInformationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetListWearablesInformationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetListWearablesInformationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetListWearablesInformationResponseValidationError{}

// Validate checks the field values on GetListWearablesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetListWearablesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetListWearablesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetListWearablesRequestMultiError, or nil if none found.
func (m *GetListWearablesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetListWearablesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if wrapper := m.GetAccount(); wrapper != nil {

		if !_GetListWearablesRequest_Account_Pattern.MatchString(wrapper.GetValue()) {
			err := GetListWearablesRequestValidationError{
				field:  "Account",
				reason: "value does not match regex pattern \"^0x[a-fA-F0-9]{40}$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if _, ok := _GetListWearablesRequest_Sort_InLookup[m.GetSort()]; !ok {
		err := GetListWearablesRequestValidationError{
			field:  "Sort",
			reason: "value must be in list [ lowest_id highest_id lowest_price highest_price]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetOffset() < 0 {
		err := GetListWearablesRequestValidationError{
			field:  "Offset",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetLimit(); val < 0 || val > 50 {
		err := GetListWearablesRequestValidationError{
			field:  "Limit",
			reason: "value must be inside range [0, 50]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetListWearablesRequestValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetListWearablesRequestValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetListWearablesRequestValidationError{
				field:  "Id",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetGender() {
		_, _ = idx, item

		if _, ok := _GetListWearablesRequest_Gender_InLookup[item]; !ok {
			err := GetListWearablesRequestValidationError{
				field:  fmt.Sprintf("Gender[%v]", idx),
				reason: "value must be in list [male female]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	for idx, item := range m.GetStatus() {
		_, _ = idx, item

		if _, ok := _GetListWearablesRequest_Status_InLookup[item]; !ok {
			err := GetListWearablesRequestValidationError{
				field:  fmt.Sprintf("Status[%v]", idx),
				reason: "value must be in list [for_sale has_offers]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if _, ok := _GetListWearablesRequest_Rarity_InLookup[m.GetRarity()]; !ok {
		err := GetListWearablesRequestValidationError{
			field:  "Rarity",
			reason: "value must be in list [common uncommon rare epic legendary mythical]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _GetListWearablesRequest_Type_InLookup[m.GetType()]; !ok {
		err := GetListWearablesRequestValidationError{
			field:  "Type",
			reason: "value must be in list [all hair skin face face_accessories top bottom shoes coat left_hand_equipment right_hand_equipment vehicles wing tail pet set]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetStat()) > 5 {
		err := GetListWearablesRequestValidationError{
			field:  "Stat",
			reason: "value must contain no more than 5 pair(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	{
		sorted_keys := make([]string, len(m.GetStat()))
		i := 0
		for key := range m.GetStat() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetStat()[key]
			_ = val

			// no validation rules for Stat[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, GetListWearablesRequestValidationError{
							field:  fmt.Sprintf("Stat[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, GetListWearablesRequestValidationError{
							field:  fmt.Sprintf("Stat[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return GetListWearablesRequestValidationError{
						field:  fmt.Sprintf("Stat[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if all {
		switch v := interface{}(m.GetOnChainId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetListWearablesRequestValidationError{
					field:  "OnChainId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetListWearablesRequestValidationError{
					field:  "OnChainId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOnChainId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetListWearablesRequestValidationError{
				field:  "OnChainId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetListWearablesRequestMultiError(errors)
	}

	return nil
}

// GetListWearablesRequestMultiError is an error wrapping multiple validation
// errors returned by GetListWearablesRequest.ValidateAll() if the designated
// constraints aren't met.
type GetListWearablesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetListWearablesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetListWearablesRequestMultiError) AllErrors() []error { return m }

// GetListWearablesRequestValidationError is the validation error returned by
// GetListWearablesRequest.Validate if the designated constraints aren't met.
type GetListWearablesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetListWearablesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetListWearablesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetListWearablesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetListWearablesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetListWearablesRequestValidationError) ErrorName() string {
	return "GetListWearablesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetListWearablesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetListWearablesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetListWearablesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetListWearablesRequestValidationError{}

var _GetListWearablesRequest_Account_Pattern = regexp.MustCompile("^0x[a-fA-F0-9]{40}$")

var _GetListWearablesRequest_Sort_InLookup = map[string]struct{}{
	"":              {},
	"lowest_id":     {},
	"highest_id":    {},
	"lowest_price":  {},
	"highest_price": {},
}

var _GetListWearablesRequest_Gender_InLookup = map[string]struct{}{
	"male":   {},
	"female": {},
}

var _GetListWearablesRequest_Status_InLookup = map[string]struct{}{
	"for_sale":   {},
	"has_offers": {},
}

var _GetListWearablesRequest_Rarity_InLookup = map[string]struct{}{
	"common":    {},
	"uncommon":  {},
	"rare":      {},
	"epic":      {},
	"legendary": {},
	"mythical":  {},
}

var _GetListWearablesRequest_Type_InLookup = map[string]struct{}{
	"all":                  {},
	"hair":                 {},
	"skin":                 {},
	"face":                 {},
	"face_accessories":     {},
	"top":                  {},
	"bottom":               {},
	"shoes":                {},
	"coat":                 {},
	"left_hand_equipment":  {},
	"right_hand_equipment": {},
	"vehicles":             {},
	"wing":                 {},
	"tail":                 {},
	"pet":                  {},
	"set":                  {},
}

// Validate checks the field values on GetListWearablesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetListWearablesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetListWearablesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetListWearablesResponseMultiError, or nil if none found.
func (m *GetListWearablesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetListWearablesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetWearables() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetListWearablesResponseValidationError{
						field:  fmt.Sprintf("Wearables[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetListWearablesResponseValidationError{
						field:  fmt.Sprintf("Wearables[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetListWearablesResponseValidationError{
					field:  fmt.Sprintf("Wearables[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Count

	if len(errors) > 0 {
		return GetListWearablesResponseMultiError(errors)
	}

	return nil
}

// GetListWearablesResponseMultiError is an error wrapping multiple validation
// errors returned by GetListWearablesResponse.ValidateAll() if the designated
// constraints aren't met.
type GetListWearablesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetListWearablesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetListWearablesResponseMultiError) AllErrors() []error { return m }

// GetListWearablesResponseValidationError is the validation error returned by
// GetListWearablesResponse.Validate if the designated constraints aren't met.
type GetListWearablesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetListWearablesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetListWearablesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetListWearablesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetListWearablesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetListWearablesResponseValidationError) ErrorName() string {
	return "GetListWearablesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetListWearablesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetListWearablesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetListWearablesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetListWearablesResponseValidationError{}
